# -*- coding: utf-8 -*-
"""Trajectory.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16rk8vLvPUjPzkHzNyPHNQnEO1g87cO27
"""

!pip install scanpy
!pip install anndata
!pip3 install igraph
!pip install celltypist
!pip install decoupler
!pip install fa2-modified
!pip install louvain
!pip install scvelo

#Import core single cell datasets
import scanpy as sc
import anndata as ad
import numpy as np
#import scvelo as scv

!mkdir -p GSM5082289_Mock
!mkdir -p GSM5082290_1dpi
!mkdir -p GSM5082291_2dpi
!mkdir -p GSM5082292_3dpi

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289_mock_barcodes.tsv.gz -O GSM5082289_Mock/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289_mock_features.tsv.gz -O GSM5082289_Mock/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289_mock_matrix.mtx.gz -O GSM5082289_Mock/matrix.mtx.gz

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290_1dpi_barcodes.tsv.gz -O GSM5082290_1dpi/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290_1dpi_features.tsv.gz -O GSM5082290_1dpi/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290_1dpi_matrix.mtx.gz -O GSM5082290_1dpi/matrix.mtx.gz

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291_2dpi_barcodes.tsv.gz -O GSM5082291_2dpi/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291_2dpi_features.tsv.gz -O GSM5082291_2dpi/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291_2dpi_matrix.mtx.gz -O GSM5082291_2dpi/matrix.mtx.gz

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292_3dpi_barcodes.tsv.gz -O GSM5082292_3dpi/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292_3dpi_features.tsv.gz -O GSM5082292_3dpi/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292_3dpi_matrix.mtx.gz -O GSM5082292_3dpi/matrix.mtx.gz

import scanpy as sc

mock_adata = sc.read_10x_mtx('/content/GSM5082289_Mock/')
dpi1_adata = sc.read_10x_mtx('/content/GSM5082290_1dpi/')
dpi2_adata = sc.read_10x_mtx('/content/GSM5082291_2dpi/')
dpi3_adata = sc.read_10x_mtx('/content/GSM5082292_3dpi/')

# QUALITY CONTROL

mock_adata.var_names_make_unique()
mock_adata.shape

dpi1_adata.var_names_make_unique()
dpi1_adata.shape

dpi2_adata.var_names_make_unique()
dpi2_adata.shape

dpi3_adata.var_names_make_unique()
dpi3_adata.shape

mock_adata.var.head()

dpi1_adata.var.head()

dpi2_adata.var.head()

dpi3_adata.var.head()

# Creating lists of MT, RIBO and HB genes for Mock sample.
mock_adata.var['MT'] = mock_adata.var_names.str.startswith("MT-")
mock_adata.var['RIBO'] = mock_adata.var_names.str.startswith(("RPS", "RPL"))
mock_adata.var['HB'] = mock_adata.var_names.str.contains(r"^HB[^P]")

mt_genes_mock = mock_adata.var[mock_adata.var['MT']]
mt_genes_mock

ribo_genes_mock = mock_adata.var[mock_adata.var['RIBO']]
ribo_genes_mock

hb_genes_mock = mock_adata.var[mock_adata.var['HB']]
hb_genes_mock

# Creating lists of MT, RIBO and HB genes for Day_1 sample.
dpi1_adata.var['MT'] = dpi1_adata.var_names.str.startswith("MT-")
dpi1_adata.var['RIBO'] = dpi1_adata.var_names.str.startswith(("RPS", "RPL"))
dpi1_adata.var['HB'] = dpi1_adata.var_names.str.contains(r"^HB[^P]")

mt_genes_dpi1 = dpi1_adata.var[dpi1_adata.var['MT']]
mt_genes_dpi1

ribo_genes_dpi1 = mock_adata.var[dpi1_adata.var['RIBO']]
ribo_genes_dpi1

hb_genes_dpi1 = mock_adata.var[dpi1_adata.var['HB']]
hb_genes_dpi1

# Creating lists of MT, RIBO and HB genes for Day_2 sample.
dpi2_adata.var['MT'] = dpi2_adata.var_names.str.startswith("MT-")
dpi2_adata.var['RIBO'] = dpi2_adata.var_names.str.startswith(("RPS", "RPL"))
dpi2_adata.var['HB'] = dpi2_adata.var_names.str.contains(r"^HB[^P]")

mt_genes_dpi2 = dpi2_adata.var[dpi2_adata.var['MT']]
mt_genes_dpi2

ribo_genes_dpi2 = dpi2_adata.var[dpi2_adata.var['RIBO']]
ribo_genes_dpi2

hb_genes_dpi2 = dpi2_adata.var[dpi2_adata.var['HB']]
hb_genes_dpi2

# Creating lists of MT, RIBO and HB genes for Day_3 sample.
dpi3_adata.var['MT'] = dpi3_adata.var_names.str.startswith("MT-")
dpi3_adata.var['RIBO'] = dpi3_adata.var_names.str.startswith(("RPS", "RPL"))
dpi3_adata.var['HB'] = dpi3_adata.var_names.str.contains(r"^HB[^P]")

mt_genes_dpi3 = dpi3_adata.var[dpi3_adata.var['MT']]
mt_genes_dpi3

ribo_genes_dpi3 = dpi3_adata.var[dpi3_adata.var['RIBO']]
ribo_genes_dpi3

hb_genes_dpi3 = dpi3_adata.var[dpi3_adata.var['HB']]
hb_genes_dpi3

# Creating QC metrics with MT, RIBO and HB genes for Mock sample.
sc.pp.calculate_qc_metrics(
    mock_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

# Creating QC metrics with MT, RIBO and HB genes for Day_1 sample.
sc.pp.calculate_qc_metrics(
    dpi1_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

# Creating QC metrics with MT, RIBO and HB genes for Day_2 sample.
sc.pp.calculate_qc_metrics(
    dpi2_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

# Creating QC metrics with MT, RIBO and HB genes for Dat_3 sample.
sc.pp.calculate_qc_metrics(
    dpi3_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (5,4)  # Adjust figure size
plt.rcParams["axes.grid"] = True  # Add grid to plots
plt.rcParams["axes.edgecolor"] = "black" # Set plot border color
plt.rcParams["axes.linewidth"] = 1.5 # Set plot border width
plt.rcParams["axes.facecolor"] = "white" # Set background color
plt.rcParams["axes.labelcolor"] = "black" # Set label color
plt.rcParams["xtick.color"] = "black" # Set x-axis tick color
plt.rcParams["ytick.color"] = "black" # Set y-axis tick color
plt.rcParams["text.color"] = "black" # Set text color

# Violin plots with cell and gene counts before filtering (MOCK).
sc.pl.violin(
    mock_adata,
    ["n_genes_by_counts", 'total_counts'],
    jitter=0.1,
    multi_panel=True,
)

# Violin plots of MT, RIBO and HB before filtering (MOCK).
sc.pl.violin(
    mock_adata,
    ['pct_counts_MT', 'pct_counts_RIBO', 'pct_counts_HB'],
    jitter=1,
    multi_panel=True,
)

# Violin plots with cell and gene counts before filtering (Day 1).
sc.pl.violin(
    dpi1_adata,
    ["n_genes_by_counts", 'total_counts'],
    jitter=0.1,
    multi_panel=True,
)

# Violin plots of MT, RIBO and HB before filtering (Day 1).
sc.pl.violin(
    dpi1_adata,
    ['pct_counts_MT', 'pct_counts_RIBO', 'pct_counts_HB'],
    jitter=1,
    multi_panel=True,
)

# Violin plots with cell and gene counts before filtering (Day 2).
sc.pl.violin(
    dpi2_adata,
    ["n_genes_by_counts", 'total_counts'],
    jitter=0.1,
    multi_panel=True,
)

# Violin plots of MT, RIBO and HB before filtering (Day 2).
sc.pl.violin(
    dpi2_adata,
    ['pct_counts_MT', 'pct_counts_RIBO', 'pct_counts_HB'],
    jitter=1,
    multi_panel=True,
)

# Violin plots with cell and gene counts before filtering (Day 3).
sc.pl.violin(
    dpi3_adata,
    ["n_genes_by_counts", 'total_counts'],
    jitter=0.1,
    multi_panel=True,
)

# Violin plots of MT, RIBO and HB before filtering (Day 3).
sc.pl.violin(
    dpi3_adata,
    ['pct_counts_MT', 'pct_counts_RIBO', 'pct_counts_HB'],
    jitter=1,
    multi_panel=True,
)

sc.pp.filter_cells(mock_adata, min_genes=200)
sc.pp.filter_genes(mock_adata, min_cells=3)
mock_adata = mock_adata[mock_adata.obs['pct_counts_MT'] < 10, :]

sc.pp.filter_cells(dpi1_adata, min_genes=200)
sc.pp.filter_genes(dpi1_adata, min_cells=3)
dpi1_adata = dpi1_adata[dpi1_adata.obs['pct_counts_MT'] < 10, :]

sc.pp.filter_cells(dpi2_adata, min_genes=200)
sc.pp.filter_genes(dpi2_adata, min_cells=3)
dpi2_adata = dpi2_adata[dpi2_adata.obs['pct_counts_MT'] < 10, :]

sc.pp.filter_cells(dpi3_adata, min_genes=200)
sc.pp.filter_genes(dpi3_adata, min_cells=3)
dpi3_adata = dpi3_adata[dpi3_adata.obs['pct_counts_MT'] < 10, :]

#sc.pp.scrublet(mock_adata)
#sc.pp.scrublet(dpi1_adata)
#sc.pp.scrublet(dpi2_adata)
#sc.pp.scrublet(dpi3_adata)

#mock_adata = mock_adata[~mock_adata.obs['predicted_doublet'], :]
#dpi1_adata = dpi1_adata[~dpi1_adata.obs['predicted_doublet'], :]
#dpi2_adata = dpi2_adata[~dpi2_adata.obs['predicted_doublet'], :]
#dpi3_adata = dpi3_adata[~dpi3_adata.obs['predicted_doublet'], :]

# NORMALIZATION

# Mock
# Copy the data for safety
mock_adata.layers["counts"] = mock_adata.X.copy()
# Standartize expression
sc.pp.normalize_total(mock_adata)
sc.pp.log1p(mock_adata)

# Day_1
# Copy the data for safety
dpi1_adata.layers["counts"] = dpi1_adata.X.copy()
# Standartize expression
sc.pp.normalize_total(dpi1_adata)
sc.pp.log1p(dpi1_adata)

# Day_2
# Copy the data for safety
dpi2_adata.layers["counts"] = dpi2_adata.X.copy()
# Standartize expression
sc.pp.normalize_total(dpi2_adata)
sc.pp.log1p(dpi2_adata)

# Day_3
# Copy the data for safety
dpi3_adata.layers["counts"] = dpi3_adata.X.copy()
# Standartize expression
sc.pp.normalize_total(dpi3_adata)
sc.pp.log1p(dpi3_adata)

#Feature selection

# Mock
sc.pp.highly_variable_genes(mock_adata, n_top_genes=1000)
sc.pl.highly_variable_genes(mock_adata)

# Day_1
sc.pp.highly_variable_genes(dpi1_adata, n_top_genes=1000)
sc.pl.highly_variable_genes(dpi1_adata)

# Day_2
sc.pp.highly_variable_genes(dpi2_adata, n_top_genes=1000)
sc.pl.highly_variable_genes(dpi2_adata)

# Day_3
sc.pp.highly_variable_genes(dpi3_adata, n_top_genes=1000)
sc.pl.highly_variable_genes(dpi3_adata)

# DIMENSIONALITY REDUCTION

# Mock
sc.tl.pca(mock_adata)
sc.pl.pca_variance_ratio(mock_adata, n_pcs=10, log=False)

# Day_1
sc.tl.pca(dpi1_adata)
sc.pl.pca_variance_ratio(dpi1_adata, n_pcs=10, log=False)

# Day_2
sc.tl.pca(dpi2_adata)
sc.pl.pca_variance_ratio(dpi2_adata, n_pcs=10, log=False)

# Day_3
sc.tl.pca(dpi3_adata)
sc.pl.pca_variance_ratio(dpi3_adata, n_pcs=10, log=False)

# Check ENO2 gene
sc.pl.pca(mock_adata, color="ENO2", cmap="coolwarm", title="ENO2_mock")
sc.pl.pca(dpi1_adata, color="ENO2", cmap="coolwarm", title="ENO2_dpi1")
sc.pl.pca(dpi2_adata, color="ENO2", cmap="coolwarm", title="ENO2_dpi2")
sc.pl.pca(dpi3_adata, color="ENO2", cmap="coolwarm", title="ENO2_dpi3")

# Check ACE2 gene
sc.pl.pca(mock_adata, color="ACE2", cmap="coolwarm", title="ACE2_mock")
sc.pl.pca(dpi1_adata, color="ACE2", cmap="coolwarm", title="ACE2_dpi1")
sc.pl.pca(dpi2_adata, color="ACE2", cmap="coolwarm", title="ACE2_dpi2")
sc.pl.pca(dpi3_adata, color="ACE2", cmap="coolwarm", title="ACE2_dpi3")

# UMAP

# Mock
sc.pp.neighbors(mock_adata)
sc.tl.umap(mock_adata)

# Day_1
sc.pp.neighbors(dpi1_adata)
sc.tl.umap(dpi1_adata)

# Day_2
sc.pp.neighbors(dpi2_adata)
sc.tl.umap(dpi2_adata)

# Day_3
sc.pp.neighbors(dpi3_adata)
sc.tl.umap(dpi3_adata)

mock_adata

dpi1_adata

dpi2_adata

dpi3_adata

# Mock
sc.pl.umap(
    mock_adata,
    color=["ENO2"],
    size=8,
    title="ENO2_mock"
)

# Day_1
sc.pl.umap(
    dpi1_adata,
    color=["ENO2"],
    size=8,
    title="ENO2_dpi1"
)

# Day_2
sc.pl.umap(
    dpi2_adata,
    color=["ENO2"],
    size=8,
    title="ENO2_dpi2"
)

# Day_3
sc.pl.umap(
    dpi3_adata,
    color=["ENO2"],
    size=8,
    title="ENO2_dpi3"
)

# Mock
sc.pl.umap(
    mock_adata,
    color=["ACE2"],
    size=8,
    title="ACE2_mock"
)

# Day_1
sc.pl.umap(
    dpi1_adata,
    color=["ACE2"],
    size=8,
    title="ACE2_dpi1"
)

# Day_2
sc.pl.umap(
    dpi2_adata,
    color=["ACE2"],
    size=8,
    title="ACE2_dpi2"
)

# Day_3
sc.pl.umap(
    dpi3_adata,
    color=["ACE2"],
    size=8,
    title="ACE2_dpi3"
)

# Leiden clustering.

# Mock
sc.tl.leiden(mock_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)

#Day_1
sc.tl.leiden(dpi1_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)

# Day_2
sc.tl.leiden(dpi2_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)

# Day_3
sc.tl.leiden(dpi3_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)

# Leiden clustering visualization.

# Mock
sc.pl.umap(
    mock_adata,
    color=["leiden_res0_5"],
    size=3,
    title="Mock"
)

# Day_1
sc.pl.umap(
    dpi1_adata,
    color=["leiden_res0_5"],
    size=3,
    title="Day_1"
)

# Day_2
sc.pl.umap(
    dpi2_adata,
    color=["leiden_res0_5"],
    size=3,
    title="Day_2"
)

# Day_3
sc.pl.umap(
    dpi3_adata,
    color=["leiden_res0_5"],
    size=3,
    title="Day_3"
)

# Leiden clustering visualization (ENO2).

# Mock
sc.pl.umap(
    mock_adata,
    color=["ENO2"],
    size=3,
    title="Mock"
)

# Day_1
sc.pl.umap(
    dpi1_adata,
    color=["ENO2"],
    size=3,
    title="Day_1"
)

# Day_2
sc.pl.umap(
    dpi2_adata,
    color=["ENO2"],
    size=3,
    title="Day_2"
)

# Day_3
sc.pl.umap(
    dpi3_adata,
    color=["ENO2"],
    size=3,
    title="Day_3"
)

# Leiden clustering visualization (ACE2).

# Mock
sc.pl.umap(
    mock_adata,
    color=["ACE2"],
    size=3,
    title="Mock"
)

# Day_1
sc.pl.umap(
    dpi1_adata,
    color=["ACE2"],
    size=3,
    title="Day_1"
)

# Day_2
sc.pl.umap(
    dpi2_adata,
    color=["ACE2"],
    size=3,
    title="Day_2"
)

# Day_3
sc.pl.umap(
    dpi3_adata,
    color=["ACE2"],
    size=3,
    title="Day_3"
)

# CELL ANNOTATION

#import decoupler as dc

# Query Omnipath and get PanglaoDB
#markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
#markers = markers[markers["human"]]

# Remove duplicated entries
#markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format because dc only accepts cell_type and genesymbol

#markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
#markers = markers[["source", "target"]]


#markers.head()

import decoupler as dc
# Define markers (re-copied from ChN3GuF7Hwwx to ensure it's available)
markers = dc.op.resource(name="PanglaoDB", organism="human")
markers = markers[markers["organ"] == 'Lungs']
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]
markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]
markers.head()

markers.shape

mock_adata.var_names

dpi1_adata.var_names

dpi2_adata.var_names

dpi3_adata.var_names

mock_adata.var.head()

import decoupler as dc
dc.mt.ulm(data=mock_adata,
          net=markers,
          tmin = 3)

score_mock = dc.pp.get_obsm(mock_adata, key="score_ulm")

mock_adata.obsm["score_ulm"].head(1)

mock_adata.obsm["score_ulm"].columns

# Rank genes Mock
mock_adata_gene_rank = dc.tl.rankby_group(score_mock, groupby="leiden_res0_5", reference="rest", method="t-test_overestim_var")
mock_adata_gene_rank = mock_adata_gene_rank[mock_adata_gene_rank["stat"] > 0]
mock_adata_gene_rank.head(5)

top_cell_type_per_group_mock = mock_adata_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group_mock.to_dict())

sc.pl.umap(score_mock, color=["leiden_res0_5"], cmap="RdBu_r")

dict_ann_mock = mock_adata_gene_rank[mock_adata_gene_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()
dict_ann_mock

mock_adata.obs["cell_type"] = mock_adata.obs["leiden_res0_5"].map(dict_ann_mock)
# Plot
sc.pl.umap(mock_adata, color='cell_type')

mock_adata.obs["cell_type"] = mock_adata.obs["leiden_res0_5"].map(dict_ann_mock)
# Plot
sc.pl.umap(mock_adata, color='cell_type', legend_loc='on data', legend_fontsize=10)