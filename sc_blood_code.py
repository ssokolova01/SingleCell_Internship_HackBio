# -*- coding: utf-8 -*-
"""sc_Blood_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1smJxImzao0oPoslWglNvmqkbcWx71zYV
"""

# Installation
!pip install scanpy
!pip install anndata
!pip3 install igraph
!pip install celltypist
!pip install decoupler
!pip install fa2-modified

# Import libraries
# Core single-cell tools
import scanpy as sc
import anndata as ad
# For cell annotation step
import decoupler as dc
# For table manipulations and vizualisation
import pandas as pd
import seaborn as sns

# Upload the data
!wget https://github.com/josoga2/sc/raw/refs/heads/main/bone_marrow.h5ad
BM_adata = sc.read_h5ad('bone_marrow.h5ad')
print (BM_adata)

# The dimensions of the dataset
BM_adata.shape

# The first 5 rows describing the genes in the dataset
BM_adata.var.head()

# The first 5 rows describing the cells (ID) in the dataset
BM_adata.obs.head()

# Both gene and cell datasets in a proper dataframe format
BM_adata.to_df()

# QUALITY CONTROL (QC)

# Step to leave only unique cells and genes
BM_adata.var_names_make_unique()
BM_adata.obs_names_make_unique()

# Search of contamination from dying cells (MT, mitochondrial genes), ribosomal transcripts (RIBO) or hemoglobin (HB).
# The thresholds are: (MT < 5%, RB < 10%, and HB < 5%).
BM_adata.var['MT'] = BM_adata.var['feature_name'].str.startswith("MT-")
BM_adata.var['RIBO'] = BM_adata.var['feature_name'].str.startswith("RPS", "RPL")
BM_adata.var['HB'] = BM_adata.var['feature_name'].str.startswith("^HB[^(P)]")

# Check results for dying cells.
mt_genes = BM_adata.var[BM_adata.var['MT']]
mt_genes

# Check results for ribosomal transcripts.
ribo_genes = BM_adata.var[BM_adata.var['RIBO']]
ribo_genes

# Check results for hemoglobin. No hemoglobin genes found.
hb_genes = BM_adata.var[BM_adata.var['HB']]
hb_genes

# Calculate the QC metrics
sc.pp.calculate_qc_metrics(
    BM_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

# QC metric assessment.

# Violin plot visualization of the number of genes expressed in each cell.
sc.pl.violin(
    BM_adata,
    ["n_genes_by_counts"],
    jitter=0.4,
    multi_panel=False,
)

# Violin plot for the total number of molecules (UMI) detected in a cell.
sc.pl.violin(
    BM_adata,
    ["total_counts"],
    jitter=0.4,
    multi_panel=False,
)

# QC metrics included in the headers of obs (cell dataset)
BM_adata.obs.head()

# QC metrics included in the headers of var (gene dataset)
BM_adata.var.head()

# Check the level of MT using visualization. MT < 2%.
sc.pl.violin(
    BM_adata,
    ["pct_counts_MT"],
    jitter=0.4,
    multi_panel=False,
)

# Check the level of RIBO using visualization. RIBO < 5%.
sc.pl.violin(
    BM_adata,
    ["pct_counts_RIBO"],
    jitter=0.4,
    multi_panel=False,
)

# There is no filtering step here, because the percentage of mitochondrial and ribosomal genes is much lower than threshold (10%).

# Doublet detection
sc.pp.scrublet(BM_adata)

# NORMALIZATION

# Save a copy of the data
BM_adata.layers["counts"] = BM_adata.X.copy()

# Normalizing to median total counts
sc.pp.normalize_total(BM_adata)
# Logarithmize the data
sc.pp.log1p(BM_adata)

# Feature selection: selecting the top 1000 most variable genes
sc.pp.highly_variable_genes(BM_adata, n_top_genes=1000)

# Visualization of the normalisation results: after (left) and before (right) normalization
sc.pl.highly_variable_genes(BM_adata )
#left is normalized
#right is not

# DIMENTIONALITY REDUCTION & CLUSTERING

# Performing PCA analysis and visualization of the principal components.
sc.tl.pca(BM_adata)
sc.pl.pca_variance_ratio(BM_adata, n_pcs=10, log=False)

# Calculate proximity of the data points between each other for further umap dimensionality reduction.
sc.pp.neighbors(BM_adata)
sc.tl.umap(BM_adata)

# Graph-based clustering using leiden algorithm.
sc.tl.leiden(BM_adata, flavor="igraph", n_iterations=2)

# Visualization of the leiden clustering.
sc.pl.umap(
    BM_adata,
    color=["leiden"],
    size=8,
)

# Resolution adjustment for Leiden clustering.
sc.tl.leiden(BM_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_3", resolution=0.3)

# Visualization of the clustering with chosen resolution.
sc.pl.umap(
    BM_adata,
    color=["leiden_res0_3"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1
)

# PREPARATION FOR THE CELL ANNOTATION AND CLUSTER ANNOTATION (step needed to translate Ensemble IDs to gene names for decoupler tool proper functioning)

# The dataset should be prepared for the cell cluster annotation part, specifically for the decoupler treatment.
# Ensemble IDs should be turned into gene names for decoupler could intake them.

# Download the table of genes from Ensemble website.
!wget wget -O result.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "CSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hsapiens_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "external_gene_name" /></Dataset></Query>'

# Rename columns of Ensemble table and check the table view.
import pandas as pd
ensembl_var = pd.read_csv('/content/result.txt', header = None)
ensembl_var.columns = ['ensembl_gene_id', 'gene_name']
ensembl_var.head(3)

# Query Omnipath and get PanglaoDB
markers_0 = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
markers_0 = markers_0[markers_0["canonical_marker"]]

# Remove duplicated entries
markers_0 = markers_0[~markers_0.duplicated(["cell_type", "genesymbol"])]

#Format because dc only accepts cell_type and genesymbol

markers_0 = markers_0.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers_0 = markers_0[["source", "target"]]

markers_0.head()

# Correct target to ensemble
markers = markers_0.merge(ensembl_var, left_on="target", right_on="gene_name", how="left")
markers = markers.drop(columns=["target"])
# Remove duplicated entries
markers = markers[~markers.duplicated(["source", "ensembl_gene_id"])]
#Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"source": "source", "ensembl_gene_id": "target"})

markers = markers[["source", "target"]]
markers = markers.dropna()

markers.head()

# Load the gene expression matrix into dc
dc.mt.ulm(data=BM_adata,
          net=markers,
          tmin = 3)

# Retrieve the score for each cell type
score = dc.pp.get_obsm(BM_adata, key="score_ulm")
score

# Preview the data
BM_adata.obsm["score_ulm"].head()

BM_adata.obsm["score_ulm"].columns

# Create the UMAP plot with resolution equal to 0.3.
score.obs['leiden_res0_3'] = BM_adata.obs['leiden_res0_3']
sc.pl.umap(score, color=["leiden_res0_3"], cmap="RdBu_r")

sc.pl.umap(
    BM_adata,
    color=["leiden_res0_3"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

# Create object score and and copy clustering labels in it.
# Copy the leiden_res0_3 column from BM_adata.obs to score.obs
score.obs['leiden_res0_3'] = BM_adata.obs['leiden_res0_3']

# Rank genes
# Find differential abundance of cell types between clusters.
BM_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_3", reference="rest", method="t-test_overestim_var")
# Filter the results of the differentially abundant cell types to only include cell types that have a positive test statistic.
BM_adata_rank = BM_adata_rank[BM_adata_rank["stat"] > 0]
# Show top rows of the result.
BM_adata_rank.head(10)

# Create a mapping of the cluster annotation (labels).
cluster_annotations = BM_adata_rank[BM_adata_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()

cluster_annotations

# Leiden clustering using cell annotation output.
BM_adata.obs['cell_type'] = BM_adata.obs['leiden_res0_3'].map(cluster_annotations)

# UMAP 2D visualization of the clusters annotated by cell type.
sc.pl.umap(
    BM_adata,
    color=['cell_type'],
    legend_loc="on data"
)

# Gene names of the found cell clusters.
available_genes = set(BM_adata.var['feature_name'])

# Gamma delta T cells
gmtc_markers = markers_0[markers_0['source'].isin(['Gamma delta T cells'])]['target']
gmtc_markers = gmtc_markers[gmtc_markers.isin(available_genes)]
gmtc_markers = gmtc_markers.drop_duplicates()

# Nuocytes
nuo_markers = markers_0[markers_0['source'].isin(['Nuocytes'])]['target']
nuo_markers = nuo_markers[nuo_markers.isin(available_genes)]
nuo_markers = nuo_markers.drop_duplicates()

# NK cells
nk_cell_markers = markers_0[markers_0['source'].isin(['NK cells'])]['target']
nk_cell_markers = nk_cell_markers[nk_cell_markers.isin(available_genes)]
nk_cell_markers = nk_cell_markers.drop_duplicates()

# Neutrophils
neutro_markers = markers_0[markers_0['source'].isin(['Neutrophils'])]['target']
neutro_markers = neutro_markers[neutro_markers.isin(available_genes)]
neutro_markers = neutro_markers.drop_duplicates()

# Monocytes
mono_markers = markers_0[markers_0['source'].isin(['Monocytes'])]['target']
mono_markers = mono_markers[mono_markers.isin(available_genes)]
mono_markers = mono_markers.drop_duplicates()

# B cells naive
bcn_markers = markers_0[markers_0['source'].isin(['B cells naive'])]['target']
bcn_markers = bcn_markers[bcn_markers.isin(available_genes)]
bcn_markers = bcn_markers.drop_duplicates()

# Plasma cells
plasma_markers = markers_0[markers_0['source'].isin(['Plasma cells'])]['target']
plasma_markers = plasma_markers[plasma_markers.isin(available_genes)]
plasma_markers = plasma_markers.drop_duplicates()

# Platelets
plt_markers = markers_0[markers_0['source'].isin(['Platelets'])]['target']
plt_markers = plt_markers[plt_markers.isin(available_genes)]
plt_markers = plt_markers.drop_duplicates()

display(gmtc_markers)

display(nuo_markers)

display(nk_cell_markers)

display(neutro_markers)

display(mono_markers)

display(bcn_markers)

display(plasma_markers)

display(plt_markers)