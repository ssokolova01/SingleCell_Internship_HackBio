# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""




"""# DNA TO PROTEIN"""

# Create a dictionary of codons and corresponding amino acids.
codon_dict = {
    "ATA": "I", "ATC": "I", "ATT": "I", "ATG": "M",
    "ACA": "T", "ACC": "T", "ACG": "T", "ACT": "T",
    "AAC": "N", "AAT": "N", "AAA": "K", "AAG": "K",
    "AGC": "S", "AGT": "S", "AGA": "R", "AGG": "R",
    "CTA": "L", "CTC": "L", "CTG": "L", "CTT": "L",
    "CCA": "P", "CCC": "P", "CCG": "P", "CCT": "P",
    "CAC": "H", "CAT": "H", "CAA": "Q", "CAG": "Q",
    "CGA": "R", "CGC": "R", "CGG": "R", "CGT": "R",
    "GTA": "V", "GTC": "V", "GTG": "V", "GTT": "V",
    "GCA": "A", "GCC": "A", "GCG": "A", "GCT": "A",
    "GAC": "D", "GAT": "D", "GAA": "E", "GAG": "E",
    "GGA": "G", "GGC": "G", "GGG": "G", "GGT": "G",
    "TCA": "S", "TCC": "S", "TCG": "S", "TCT": "S",
    "TTC": "F", "TTT": "F", "TTA": "L", "TTG": "L",
    "TAC": "Y", "TAT": "Y", "TAA": "Stop", "TAG": "Stop",
    "TGC": "C", "TGT": "C", "TGA": "Stop", "TGG": "W",
}

def dna_to_protein(DNAseq):
    # Clean the input: remove spaces, newlines, and convert to uppercase.
    DNAseq_valid = DNAseq.replace('\n', '').replace(' ', '').upper().strip()

    # Check and validate the sequence. It should only contain A, T, C, G
    valid_bases = {'A', 'T', 'C', 'G'}
    if not DNAseq_valid:
        print("Error: DNA sequence is empty.")
        return None
    elif any(base not in valid_bases for base in DNAseq_valid):
        print("Error: DNA sequence contains invalid characters. Only A, T, C, G are allowed.")
        return None

    # Create a storage string for a protein sequence.
    protein_seq = ""

    # Create a loop to go through DNA sequence and translate it in protein sequence one amino acid per codon.
    # If there is no codon in the end (there are less than 3 residues in the end of a DNA sequence), translation will be stopped.
    for i in range(0, len(DNAseq_valid), 3):
        codon = DNAseq_valid[i:i + 3]
        if len(codon) < 3:
            break
    # Go to the dictionary and find the suitable amino acid for the current codon in the translated DNA sequence.
    # If the Stop codon is found, the translation will end. Another check for tha valid codon (this time for its presence in the dictionary).
        if codon in codon_dict:
            amino_acid = codon_dict[codon]
            if amino_acid == "Stop":
                break
            protein_seq += amino_acid
        else:
            print(f"Warning: Codon {codon} is not valid.")
            break

    return protein_seq

# Example for DNA sequence (the beginning of the TP53 gene sequence taken from RefSeq NCBI)
DNAseq = "ctccttggtt caagtaattc tcctgcctca gactccagag tagctgggat tacaggcgcc"
protein = dna_to_protein(DNAseq)
print("Protein sequence:", protein)

#***********************************************************************************************************************************************************************************#

"""# HAMMING DISTANCE"""

# Start function and assign the variables length to check the number of sumbols in the lines and print the count.
def hamming_distance(str1, str2):
  len1 = len(str1)
  len2 = len(str2)
  print(f"Length of str1 ('{str1}'): {len1}")
  print(f"Length of str2 ('{str2}'): {len2}")
# Set the condition (difference in line length) to raise an error.
  if len(str1) != len(str2):
    raise ValueError("Different word length! Hamming distance requires strings of equal length.")
# Set the start of the difference between two lines count, equal to 0.
  distance = 0
# Use range function to move through the line and to iterate every symbol.
  for i in range(len(str1)):
        if str1[i] != str2[i]:
            distance += 1
# Print lines for check         
  print(f"String 1: {str1}")
  print(f"String 2: {str2}")
# Return the result
  return distance
# Example
str1 = "svetlana"
str2 = "svetzavr"
distance = hamming_distance(str1, str2)
print(f"Hamming distance between '{str1}' and '{str2}' is '{distance}'")

#************************************************************************************************************************************************************************************#

"""# PLOT REPRODUCTION"""

# Part A – Gene Expression Analysis

# 1. a. Heatmap
# Use the normalized gene expression dataset to plot a clustered heatmap of the top differentially expressed genes between HBR and UHR samples.
# Label both genes and samples.
# Use a color gradient (e.g., Blues) to indicate expression levels.

# Import libraries for data visualisation
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Load the dataset
url = 'https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/hbr_uhr_top_deg_normalized_counts.csv'
df = pd.read_csv(url)

# Check the dataset structure
print(df.head())
print(df.columns)

# There is no name for the column containing genes. 
# Thus, set the 'Unnamed: 0' column (gene names) as the index and rename it to "Gene"
df = df.set_index('Unnamed: 0')
df.index.name = 'Gene'

# Find the variance across samples for each gene
# to identify variance across samples for each gene
variance = df.var(axis=1)
# Sort by the variance and select the top N genes, here 50 genes were selected
top_genes = variance.sort_values(ascending=False).head(50).index
# Create new dataset which contains only highly expressed genes (50 chosen)
df_top_genes = df.loc[top_genes]

# Set the figure size
plt.figure(figsize=(8, 8))
# Generate the heatmap using sns.clustermap
# Save clustermap variable for further customization
# Heatmap settings: 
# cell color, line color, line width, no annotations in the cells, 
# clustering and labeling by rows and columns, dendrogram size, 
# color gradient legend size and popsition)
g = sns.clustermap(df_top_genes,
                   cmap='Blues',
                   annot=False,
                   linecolor='black',
                   linewidths=0.5,
                   xticklabels=True,
                   yticklabels=True,
                   row_cluster=True,
                   col_cluster=True,
                   dendrogram_ratio=(0.17, 0.17),
                   cbar_pos=(0.05, 0.8, 0.03, 0.1)
                  )

# Add and customize the title (size and distance from the plot)
g.fig.suptitle('Heatmap of Top Differentially Expressed Genes (HBR vs UHR)', fontsize=12, y=1.02)

# Delete the name of the y-axis
g.ax_heatmap.set_ylabel('')

# Show the plot
plt.show()
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 1. b. Volcano Plot
# Plot log2FoldChange vs log10(Padj) from the DEG results.
# Color points by significance:
# Upregulated: green
# Downregulated: orange
# Not significant: grey
# Add dashed vertical lines at log2FoldChange = ±1.

# Load the dataset
url = "https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/hbr_uhr_deg_chr22_with_significance.csv"
data = pd.read_csv(url)

# Check the dataset structure
print(data.head())

# Extract necessary columns
log2fc = data['log2FoldChange']
padj = data['PAdj']

# Calculate -log10(Padj) for the y-axis and set the threshold (0.05)
log10_padj = -np.log10(padj)
significance_threshold = 0.05

# Create a new column in the dataset table to for coloring the gene points based
# on their significance using log2FoldChange levels
data['Color'] = 'grey'
data.loc[(data['PAdj'] < significance_threshold) & (data['log2FoldChange'] > 1), 'Color'] = 'green'
data.loc[(data['PAdj'] < significance_threshold) & (data['log2FoldChange'] < -1), 'Color'] = 'orange'

# Set up Seaborn style for the plot
sns.set(style="whitegrid")
# Create the volcano plot
plt.figure(figsize=(10, 8))
# Set the scatterplot style parameter to highlight data insights
sns.scatterplot(x=log2fc, y=log10_padj, hue=data['Color'], palette={"green": "green", "orange": "orange", "grey": "grey"},
                edgecolor="w", alpha=0.7, s=100)

# Add vertical lines at log2FoldChange = ±1
plt.axvline(x=1, color='black', linestyle='--')
plt.axvline(x=-1, color='black', linestyle='--')

# Add labels and title
plt.xlabel('Log2 Fold Change', fontsize=14)
plt.ylabel('-Log10 (Adjusted P-value)', fontsize=14)
plt.title('Volcano Plot: Differential Expression Results', fontsize=16)

# Custom the legend
handles, labels = plt.gca().get_legend_handles_labels()
labels = ['down', 'ns', 'up']
plt.legend(handles, labels, title='significance', loc='upper right')

# Show the plot
plt.show()
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Part B – Breast Cancer Data Exploration

# 1. c. Scatter Plot (radius vs texture)
# Plot texture_mean vs radius_mean and color points by diagnosis (M = malignant, B = benign).

# Load the dataset
url = "https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/data-3.csv"
df = pd.read_csv(url)

# Create the scatter plot
plt.figure(figsize=(7, 7))
sns.scatterplot(data=df,
                x='radius_mean',
                y='texture_mean',
                hue='diagnosis',
                style='diagnosis',
                markers='o',
                s=100)
# Remove the gridlines
plt.grid(False)

# Set the labels and the title
plt.title('Scatter Plot of Radius vs Texture Mean', fontsize=14)
plt.xlabel('radius_mean', fontsize=12)
plt.ylabel('texture_mean', fontsize=12)

# Display the legend
# Customize the legend size, position and information
plt.legend(
    title='diagnosis',
    fontsize=12,
    loc='upper right',
    bbox_to_anchor=(1, 1),
    borderpad=1.5,
    labelspacing=0.8,
    title_fontsize='13',
    borderaxespad=0.5
)

# Show the plot
plt.show()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 2. d. Correlation Heatmap
# Compute the correlation matrix of six key features:
# radius_mean, texture_mean, perimeter_mean, area_mean, smoothness_mean, compactness_mean.
# Plot as a heatmap with correlation values annotated.

# Load the dataset
url = 'https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/data-3.csv'
df = pd.read_csv(url)

# Select six key features
features = [
    "radius_mean",
    "texture_mean",
    "perimeter_mean",
    "area_mean",
    "smoothness_mean",
    "compactness_mean"
]
# Compute correlation matrix
corr_matrix = df[features].corr()

# Plot the heatmap with size, color and position settings
plt.figure(figsize=(6, 6.5))
sns.heatmap(
    corr_matrix,
    annot=True,
    fmt=".1f",
    cmap="Blues",
    linewidths=0.5,
    linecolor='black',
    square=False,
    cbar_kws={"shrink": 1}
)

# Add title
plt.title("Correlation Heatmap of Key Breast Cancer Features", fontsize=12, pad=15)

# Adjust layout
plt.tight_layout()

# Show the plot
plt.show()
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 3. e. Scatter Plot (smoothness vs compactness)
# Plot compactness_mean vs smoothness_mean colored by diagnosis.
# Include gridlines and clear axis labels.

# Load the dataset
url = "https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/data-3.csv"
df = pd.read_csv(url)

# Round the columns to the desired decimal places using numpy
df['smoothness_mean'] = np.round(df['smoothness_mean'], 3)  # Round to 3 decimals for smoothness
df['compactness_mean'] = np.round(df['compactness_mean'], 2)  # Round to 2 decimals for compactness

# Create the scatter plot
plot = sns.scatterplot(
    data=df,
    x="smoothness_mean",
    y="compactness_mean",
    hue="diagnosis",  # Color points based on diagnosis
    style="diagnosis",  # Use different markers for 'M' and 'B'
    markers=["o"],  # Use circle markers only
    s=100  # Size of the markers
)

# Set labels and title
plt.xlabel('smoothness_mean', fontsize=12)
plt.ylabel('compactness_mean', fontsize=12)
plt.title('Scatter Plot of Smoothness vs Compactness by Diagnosis', fontsize=14)

# Customize the x-axis ticks manually (set the tick spacing to 0.025)
plot.set_xlim(0.040, 0.16)
plot.set_xticks([0.05, 0.075, 0.10, 0.125, 0.15])  # Adjust the range and step of x-ticks to 0.025

# Add a legend with custom labels
plt.legend(title="diagnosis", loc="upper left", fontsize=14)

# Show the plot
plt.show()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 4. f. Density Plot (area distribution)
# Plot kernel density estimates (KDE) of area_mean for both M and B diagnoses on the same axis.
# Add legend and labeled axes.

# Load the dataset
url = "https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/data-3.csv"
df = pd.read_csv(url)

# Plot KDE for 'area_mean' for both Malignant (M) and Benign (B) diagnoses
plt.figure(figsize=(10, 6))  # Set the figure size

sns.kdeplot(data=df[df['diagnosis'] == 'M'], x='area_mean', fill=True, color='blue', label='M', alpha=0.5)
sns.kdeplot(data=df[df['diagnosis'] == 'B'], x='area_mean', fill=True, color='orange', label='B', alpha=0.5)

# Adding title and labels
plt.title('Density Plot of Area Mean by Diagnosis', fontsize=14)
plt.xlabel('area_mean', fontsize=12)
plt.ylabel('Density', fontsize=12)

# Adding legend
plt.legend(title='Diagnosis', 
           fontsize=12,
           loc='upper right',
           bbox_to_anchor=(1, 1),
           borderpad=1,
           labelspacing=0.5,
           title_fontsize='13',
           borderaxespad=0.5
           )

# Show the plot
plt.show()
