# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""
"""# DNA TO PROTEIN"""

# Create a dictionary of codons and corresponding amino acids.
codon_dict = {
    "ATA": "I", "ATC": "I", "ATT": "I", "ATG": "M",
    "ACA": "T", "ACC": "T", "ACG": "T", "ACT": "T",
    "AAC": "N", "AAT": "N", "AAA": "K", "AAG": "K",
    "AGC": "S", "AGT": "S", "AGA": "R", "AGG": "R",
    "CTA": "L", "CTC": "L", "CTG": "L", "CTT": "L",
    "CCA": "P", "CCC": "P", "CCG": "P", "CCT": "P",
    "CAC": "H", "CAT": "H", "CAA": "Q", "CAG": "Q",
    "CGA": "R", "CGC": "R", "CGG": "R", "CGT": "R",
    "GTA": "V", "GTC": "V", "GTG": "V", "GTT": "V",
    "GCA": "A", "GCC": "A", "GCG": "A", "GCT": "A",
    "GAC": "D", "GAT": "D", "GAA": "E", "GAG": "E",
    "GGA": "G", "GGC": "G", "GGG": "G", "GGT": "G",
    "TCA": "S", "TCC": "S", "TCG": "S", "TCT": "S",
    "TTC": "F", "TTT": "F", "TTA": "L", "TTG": "L",
    "TAC": "Y", "TAT": "Y", "TAA": "Stop", "TAG": "Stop",
    "TGC": "C", "TGT": "C", "TGA": "Stop", "TGG": "W",
}

def dna_to_protein(DNAseq):
    # Clean the input: remove spaces, newlines, and convert to uppercase.
    DNAseq_valid = DNAseq.replace('\n', '').replace(' ', '').upper().strip()

    # Check and validate the sequence. It should only contain A, T, C, G
    valid_bases = {'A', 'T', 'C', 'G'}
    if not DNAseq_valid:
        print("Error: DNA sequence is empty.")
        return None
    elif any(base not in valid_bases for base in DNAseq_valid):
        print("Error: DNA sequence contains invalid characters. Only A, T, C, G are allowed.")
        return None

    # Create a storage string for a protein sequence.
    protein_seq = ""

    # Create a loop to go through DNA sequence and translate it in protein sequence one amino acid per codon.
    # If there is no codon in the end (there are less than 3 residues in the end of a DNA sequence), translation will be stopped.
    for i in range(0, len(DNAseq_valid), 3):
        codon = DNAseq_valid[i:i + 3]
        if len(codon) < 3:
            break
    # Go to the dictionary and find the suitable amino acid for the current codon in the translated DNA sequence.
    # If the Stop codon is found, the translation will end. Another check for tha valid codon (this time for its presence in the dictionary).
        if codon in codon_dict:
            amino_acid = codon_dict[codon]
            if amino_acid == "Stop":
                break
            protein_seq += amino_acid
        else:
            print(f"Warning: Codon {codon} is not valid.")
            break

    return protein_seq

# Example for DNA sequence (the beginning of the TP53 gene sequence taken from RefSeq NCBI)
DNAseq = "ctccttggtt caagtaattc tcctgcctca gactccagag tagctgggat tacaggcgcc"
protein = dna_to_protein(DNAseq)
print("Protein sequence:", protein)

"""# HAMMING DISTANCE"""

# Start function and assign the variables length to check the number of sumbols in the lines and print the count.
def hamming_distance(str1, str2):
  len1 = len(str1)
  len2 = len(str2)
  print(f"Length of str1 ('{str1}'): {len1}")
  print(f"Length of str2 ('{str2}'): {len2}")
# Set the condition (difference in line length) to raise an error.
  if len(str1) != len(str2):
    raise ValueError("Different word length! Hamming distance requires strings of equal length.")
# Set the start of the difference between two lines count, equal to 0.
  distance = 0
# Use range function to move through the line and to iterate every symbol.
  for i in range(len(str1)):
        if str1[i] != str2[i]:
            distance += 1
# Print lines for check         
  print(f"String 1: {str1}")
  print(f"String 2: {str2}")
# Return the result
  return distance
# Example
str1 = "svetlana"
str2 = "svetzavr"
distance = hamming_distance(str1, str2)
print(f"Hamming distance between '{str1}' and '{str2}' is '{distance}'")

"""# PLOT REPRODUCTION"""
# 1. a. Heatmap
# Use the normalized gene expression dataset to plot a clustered heatmap of the top differentially expressed genes between HBR and UHR samples.
# Label both genes and samples.
# Use a color gradient (e.g., Blues) to indicate expression levels.

# Import libraries for data visualisation
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Load the dataset using URL
url = 'https://raw.githubusercontent.com/HackBio-Internship/2025_project_collection/refs/heads/main/Python/Dataset/hbr_uhr_top_deg_normalized_counts.csv'
df = pd.read_csv(url)

# Check the dataset structure
print(df.head())

# Find the variance across samples for each gene 
# to identify variance across samples for each gene
variance = df.var(axis=1)
# Sort by the variance and select the top N genes, here 50 genes were selected
top_genes = variance.sort_values(ascending=False).head(50).index
# Create new dataset which contains only highly expressed genes (50 chosen)
df_top_genes = df.loc[top_genes]

# Set of the figure size
plt.figure(figsize=(12, 8))
# Generate the heatmap: settings description:
# set the color gradient for expression levels
# create annotation with values
# set the number of decimal places for expression levels meanings
# set line width between cells
# label for the color bar
# label the columns (for samples)
# label the rows (for genes)
sns.clustermap(df_top_genes,
            cmap='Blues',
            annot=True,
            fmt='.2f',
            linewidths=0.5,
            cbar_kws={'label': 'Expression Level'},
            xticklabels=True,
            yticklabels=True)
# Add title to the heatmap
plt.title('Heatmap of Top Differentially Expressed Genes (HBR vs UHR)', fontsize=16)
# Show the plot
plt.tight_layout()
plt.show()

# 1. b. Volcano Plot
# Plot log2FoldChange vs log10(Padj) from the DEG results.
# Color points by significance:
# Upregulated: green
# Downregulated: orange
# Not significant: grey
# Add dashed vertical lines at log2FoldChange = Â±1.


